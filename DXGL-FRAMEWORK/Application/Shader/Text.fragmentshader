#version 330 core

// Interpolated values from the vertex shaders
in vec3 vertexPosition_cameraspace;
in vec3 fragmentColor;
in vec3 vertexNormal_cameraspace;
in vec2 texCoord;

// Ouput data
out vec4 color;

struct Light {
	int type;
	vec3 position_cameraspace;
	vec3 color;
	float power;
	float kC;
	float kL;
	float kQ;
	vec3 spotDirection;
	float cosCutoff;
	float cosInner;
	float exponent;
};

struct Material {
	vec3 kAmbient;
	vec3 kDiffuse;
	vec3 kSpecular;
	float kShininess;
};

float getAttenuation(Light light, float distance) {
	if(light.type == 1)
		return 1;
	else
		return 1 / max(1, light.kC + light.kL * distance + light.kQ * distance * distance);
}

float getSpotlightEffect(Light light, vec3 lightDirection) {
	vec3 S = normalize(light.spotDirection);
	vec3 L = normalize(lightDirection);
	float cosDirection = dot(L, S);
	return smoothstep(light.cosCutoff, light.cosInner, cosDirection);
	if(cosDirection < light.cosCutoff)
		return 0;
	else
		return 1; //pow(cosDirection, light.exponent);
}

// Constant values
const int MAX_LIGHTS = 8;

// Values that stay constant for the whole mesh.
uniform bool lightEnabled;
uniform Light lights[MAX_LIGHTS];
uniform Material material;
uniform int numLights;
uniform bool colorTextureEnabled;
uniform sampler2D colorTexture;
uniform bool textEnabled;
uniform vec3 textColor;

uniform bool fogEnabled;
uniform vec3 fogColor;
uniform float fogDensity;
uniform float fogMinDistance;
uniform float fogMaxDistance;

void main(){
	// Material properties
	vec4 materialColor;
	if(colorTextureEnabled == true)
		materialColor = texture2D( colorTexture, texCoord );
	else
		materialColor = vec4( fragmentColor, 1 );
	if(lightEnabled == true)
	{
		// Vectors
		vec3 eyeDirection_cameraspace = - vertexPosition_cameraspace;
		vec3 E = normalize(eyeDirection_cameraspace);
		vec3 N = normalize( vertexNormal_cameraspace );
		
		color = 
			// Ambient : simulates indirect lighting
			materialColor * vec4(material.kAmbient, 1);
		
		for(int i = 0; i < numLights; ++i)
		{
			// Light direction
			float spotlightEffect = 1;
			vec3 lightDirection_cameraspace;
			if(lights[i].type == 1) {
				lightDirection_cameraspace = lights[i].position_cameraspace;
			}
			else if(lights[i].type == 2) {
				lightDirection_cameraspace = lights[i].position_cameraspace - vertexPosition_cameraspace;
				spotlightEffect = getSpotlightEffect(lights[i], lightDirection_cameraspace);
			}
			else {
				lightDirection_cameraspace = lights[i].position_cameraspace - vertexPosition_cameraspace;
			}
			// Distance to the light
			float distance = length( lightDirection_cameraspace );
			
			// Light attenuation
			float attenuationFactor = getAttenuation(lights[i], distance);

			vec3 L = normalize( lightDirection_cameraspace );
			float cosTheta = clamp( dot( N, L ), 0, 1 );
			
			vec3 R = reflect(-L, N);
			float cosAlpha = clamp( dot( E, R ), 0, 1 );
			
			color += 
				// Diffuse : "color" of the object
				materialColor * vec4(material.kDiffuse, 1) * vec4(lights[i].color, 1) * lights[i].power * cosTheta * attenuationFactor * spotlightEffect +
				
				// Specular : reflective highlight, like a mirror
				vec4(material.kSpecular, materialColor.a) * vec4(lights[i].color, 1) * lights[i].power * pow(cosAlpha, material.kShininess) * attenuationFactor * spotlightEffect;
		}
	}
	else
		color = materialColor;

	
	

	if (fogEnabled)
	{
		float fogDistance = length(vertexPosition_cameraspace);
		float fogFactor = (fogDistance - fogMinDistance) / (fogMaxDistance - fogMinDistance);

		// Think of fogFactor like a slider between 0 and 1 that determines how much proportion
		// of fog there is compared to no fog (e.g. fogFactor = 0.5f, 50% of maximum fogDensity)
		if (fogFactor >= 1.f)
		{
			fogFactor = 1.f;
		}
		else if (fogFactor <= 0.f)
		{
			fogFactor = 0.f;
		}

		// fogDensity determines how much fog there is
		// finalColor is determined by a somewhat-ratio of fog : noFog
		fogFactor *= fogDensity;
		vec4 finalColor = (vec4(fogColor, 1.f) * (fogFactor)) + (color * (1 - fogFactor));
		color = finalColor;
	}

	if(textEnabled == true)
		color *= vec4( textColor, 1 );
}